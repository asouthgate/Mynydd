#version 450

layout(local_size_x = 256) in;

layout(set = 0, binding = 0) readonly buffer InputData {
    uint values[];
};

layout(set = 0, binding = 1) readonly buffer HistogramData {
    uint histogram[]; // numBins elements - full histogram
};

layout(set = 0, binding = 2) buffer OutputData {
    uint sortedValues[];
};

layout(set = 0, binding = 3) uniform Params {
    uint bitOffset;
    uint numBins;
    uint totalSize;
} params;

shared uint localBinOffsets[256]; // max numBins=256, adjust as needed
shared uint localBinCounters[256];

void main() {
    uint lid = gl_LocalInvocationID.x;
    uint gid = gl_GlobalInvocationID.x;

    // Step 1: thread 0 computes prefix sum (exclusive scan) of histogram into localBinOffsets
    if (lid == 0) {
        uint sum = 0;
        for (uint i = 0; i < params.numBins; i++) {
            localBinOffsets[i] = sum;
            sum += histogram[i];
        }
    }
    barrier();

    // Step 2: initialize local counters per bin to zero
    for (uint i = lid; i < params.numBins; i += gl_WorkGroupSize.x) {
        localBinCounters[i] = 0;
    }
    barrier();

    // Step 3: each thread processes one input element (if within range)
    if (gid < params.totalSize) {
        uint v = values[gid];
        uint bin = (v >> params.bitOffset) & (params.numBins - 1);

        // Atomically increment counter for this bin and get local index
        uint localIndex = atomicAdd(localBinCounters[bin], 1);

        // Calculate final position in output using bin offset + localIndex
        uint pos = localBinOffsets[bin] + localIndex;

        sortedValues[pos] = v;
    }
}