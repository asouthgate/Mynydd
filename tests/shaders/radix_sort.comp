#version 450

layout(local_size_x = 256) in;

layout(set = 0, binding = 0) readonly buffer InputBuffer {
    uint values[];
};

layout(set = 0, binding = 1) readonly buffer WorkgroupPrefixSums {
    uint workgroupPrefixSums[]; // layout: numBins * groupCount
};

layout(set = 0, binding = 2) readonly buffer GlobalPrefixSum {
    uint globalPrefixSum[]; // numBins elements
};

layout(set = 0, binding = 3) buffer OutputBuffer {
    uint sortedValues[];
};

layout(set = 0, binding = 4) uniform Params {
    uint bitOffset;
    uint numBins;
    uint totalSize;
    uint workgroupSize;
    uint groupCount;
} params;

// Per-bin atomic counters shared within the workgroup
shared uint localBinCounters[256]; // max bins

void main() {
    uint localID = gl_LocalInvocationID.x;
    uint globalID = gl_GlobalInvocationID.x;
    uint workgroupID = gl_WorkGroupID.x;

    localBinCounters[localID] = 0u;
    barrier();

    if (globalID >= params.totalSize) {
        return;
    }

    uint v = values[globalID];
    uint bin = (v >> params.bitOffset) & (params.numBins - 1);

    // Step 1: Atomically increment the local bin counter to get the local index.
    uint localIndex = atomicAdd(localBinCounters[bin], 1u);

    // Step 2: Compute the base position for the element.
    // This position is the sum of the global count of smaller bins and the
    // count of previous workgroups for this specific bin.
    uint basePos = globalPrefixSum[bin] + workgroupPrefixSums[bin * params.groupCount + workgroupID];

    // Step 3: Add the local index to the base position to get the final, unique position.
    uint pos = basePos + localIndex;

    // Step 4: Write the value to its final sorted position.
    sortedValues[pos] = v;

    sortedValues[globalID] = v;
}