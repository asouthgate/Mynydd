// Normalize a float position (0..1) to an int bin
int binPosition(float normPos, int nbits) {
    return int(clamp(normPos, 0.0, 1.0) * float((1 << nbits) - 1) + 0.5);
}


// Split bits by inserting zeros between them (2D Morton helper)
int part1By1(int x) {
    x &= 0x0000ffff;                  // 16 bits
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;
    return x;
}

// Split bits for 3D Morton helper
int part1By2(int x) {
    x &= 0x000003ff;                  // 10 bits
    x = (x | (x << 16)) & 0x030000FF;
    x = (x | (x << 8))  & 0x0300F00F;
    x = (x | (x << 4))  & 0x030C30C3;
    x = (x | (x << 2))  & 0x09249249;
    return x;
}

// Interleave two int coordinates into a 32-bit Morton code
int morton2D(int x, int y) {
    return (part1By1(y) << 1) | part1By1(x);
}

// Interleave three int coordinates into a 32-bit Morton code
int morton3D(int x, int y, int z) {
    return (part1By2(z) << 2) | (part1By2(y) << 1) | part1By2(x);
}

int morton3D_loop(int x, int y, int z, int nbits) {
    int code = 0;
    for (int i = 0; i < nbits; ++i) {
        code |= ((x >> i) & 1) << (3*i);
        code |= ((y >> i) & 1) << (3*i + 1);
        code |= ((z >> i) & 1) << (3*i + 2);
    }
    return code;
}

// Complete binning + interleaving for 2D
int encodeMorton2D(float normX, float normY, int nbits) {
    int bx = binPosition(normX, nbits);
    int by = binPosition(normY, nbits);
    return morton2D(bx, by);
}

// Complete binning + interleaving for 3D
int encodeMorton3D(float normX, float normY, float normZ, int nbits) {
    int bx = binPosition(normX, nbits);
    int by = binPosition(normY, nbits);
    int bz = binPosition(normZ, nbits);
    return morton3D(bx, by, bz);
}

// Normalize a float position (0..1) to a uint bin
uint binPosition(float normPos, uint nbits) {
    return uint(clamp(normPos, 0.0, 1.0) * float((1u << nbits) - 1u) + 0.5);
}

// Split bits by inserting zeros between them (2D Morton helper)
uint part1By1(uint x) {
    x &= 0x0000ffffu;                  // 16 bits
    x = (x | (x << 8)) & 0x00FF00FFu;
    x = (x | (x << 4)) & 0x0F0F0F0Fu;
    x = (x | (x << 2)) & 0x33333333u;
    x = (x | (x << 1)) & 0x55555555u;
    return x;
}

// Split bits for 3D Morton helper
uint part1By2(uint x) {
    x &= 0x000003FFu;                  // 10 bits
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

// Interleave two uint coordinates into a 32-bit Morton code
uint morton2D(uint x, uint y) {
    return (part1By1(y) << 1) | part1By1(x);
}

// Interleave three uint coordinates into a 32-bit Morton code
uint morton3D(uint x, uint y, uint z) {
    return (part1By2(z) << 2) | (part1By2(y) << 1) | part1By2(x);
}

// Loop-based 3D Morton for arbitrary nbits
uint morton3D_loop(uint x, uint y, uint z, uint nbits) {
    uint code = 0u;
    for (uint i = 0u; i < nbits; ++i) {
        code |= ((x >> i) & 1u) << (3u*i);
        code |= ((y >> i) & 1u) << (3u*i + 1u);
        code |= ((z >> i) & 1u) << (3u*i + 2u);
    }
    return code;
}

// Complete binning + interleaving for 2D
uint encodeMorton2D(float normX, float normY, uint nbits) {
    uint bx = binPosition(normX, nbits);
    uint by = binPosition(normY, nbits);
    return morton2D(bx, by);
}

// Complete binning + interleaving for 3D
uint encodeMorton3D(float normX, float normY, float normZ, uint nbits) {
    uint bx = binPosition(normX, nbits);
    uint by = binPosition(normY, nbits);
    uint bz = binPosition(normZ, nbits);
    return morton3D(bx, by, bz);
}