#version 450
layout(local_size_x = 256) in;

#extension GL_GOOGLE_include_directive : enable
#include "morton_kernels.comp.kern"

struct ParticlePos {
    vec3 position;
};

struct CellInfo {
    uint left;
    uint right;
};

// THESE SHOULD BE SORTED
layout(set = 0, binding = 0) readonly buffer InputDensities {
    float input_densities[];
};

layout(set = 0, binding = 1) readonly buffer InputPositions {
    ParticlePos input_positions[];
};

layout(set = 0, binding = 2) readonly buffer SortedKeys {
    uint keys[];
};

layout(set = 0, binding = 3) readonly buffer FlatCells {
    CellInfo flat_cells[];
};

layout(set = 0, binding = 4) readonly buffer Cells {
    CellInfo cells[];
};

layout(set = 0, binding = 5) buffer Densities {
    float densities[];
};

layout(push_constant) uniform Params {
    uint nBits;
    uint nParticles;
    vec3 domainMin;
    vec3 domainMax;
    int d;
} pc;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint key = keys[idx];

    vec3 pos = input_positions[idx].position;
    uvec3 ijk = xyz2ijk(pos, pc.nBits);
    uint flat_key = ijk2ak(ijk, pc.nBits);

    //CellInfo cell = cells[key];
    CellInfo cell = flat_cells[flat_key];

    float densitySum = 0.0;
    //uint count = cell.right - cell.left;
    uint count = 0;

    int d = pc.d;
    uint maxg = 1 << pc.nBits;
    for (int di = -d; di <= d; ++di) {
        for (int dj = -d; dj <= d; ++dj) {        
            for (int dk = -d; dk <= d; ++dk) {
                
                uint ip = uint(int(ijk.x) + di);
                uint jp = uint(int(ijk.y) + dj);
                uint kp = uint(int(ijk.z) + dk);

                if (ip >= 0 && ip < maxg 
                    && jp >= 0 && jp < maxg
                    && kp >= 0 && kp < maxg
                ) {
                    uint flat_keyp = ijk2ak(uvec3(ip,jp,kp), pc.nBits);
                    CellInfo cell = flat_cells[flat_keyp];
                    // Iterate all neighbors in the same bin
                    for (uint i = cell.left; i < cell.right; i++) {
                        densitySum += input_densities[i];
                        count += 1;
                    }
                }
            }
        }
    }
 

    // Store average density (or 0 if no neighbors)
    densities[idx] = (count > 0) ? densitySum / float(count) : 0.0;
    //densities[idx] = float(count);
}