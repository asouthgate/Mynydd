#version 450
layout(local_size_x = 256) in;

#extension GL_GOOGLE_include_directive : enable

struct Vec3Wrapper {
    vec3 data;
};

struct CellInfo {
    uint left;
    uint right;
};

// THESE SHOULD BE SORTED
layout(set = 0, binding = 0) readonly buffer InputDensities {
    float input_densities[];
};

layout(set = 0, binding = 1) readonly buffer InputPositions {
    Vec3Wrapper input_positions[];
};

layout(set = 0, binding = 0) readonly buffer InputPressures {
    float input_pressures[];
};

layout(set = 0, binding = 2) readonly buffer FlatCells {
    CellInfo flat_cells[];
};

layout(set = 0, binding = 3) buffer PressureForces {
    Vec3Wrapper pressure_forces[];
};

layout(push_constant) uniform Params {
    uint nBits;
    uint nParticles;
    vec3 domainMin;
    vec3 domainMax;
    int d;
} pc;

#include "morton_kernels.comp.kern"
#include "kernels.comp.kern"
#include "nbr_kernel.comp.kern"

void main() {
    uint idx = gl_GlobalInvocationID.x;

    vec3 pos = input_positions[idx].data;
    uvec3 ijk = xyz2ijk(pos, pc.nBits);
    uint flat_key = ijk2ak(ijk, pc.nBits);

    CellInfo cell = flat_cells[flat_key];

    float densitySum = 0.0;
    //uint count = cell.right - cell.left;

    int d = pc.d;
    uint maxg = 1 << pc.nBits;

    CellInfo neighborCells[MAX_CELLS];
    uint cellCount;
    gather_neighbor_cells(ijk, d, maxg, neighborCells, cellCount);

    // now consume neighbors
    for (uint c = 0u; c < cellCount; ++c) {
        CellInfo cell = neighborCells[c];
        for (uint i = cell.left; i < cell.right; ++i) {
            float dist = length(input_positions[i].data - pos);
            densitySum += cal_rho_ij(1.0, dist, 1.0);
        }
    }

    //densities[idx] = densitySum;

}