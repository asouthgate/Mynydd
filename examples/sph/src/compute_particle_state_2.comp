#version 450
layout(local_size_x = 256) in;

#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_gpu_shader_fp64 : enable

struct dVec3Wrapper {
    dvec3 data;
};

struct CellInfo {
    uint left;
    uint right;
};

// THESE SHOULD BE SORTED
layout(set = 0, binding = 0) readonly buffer InputDensities {
    double input_densities[];
};

layout(set = 0, binding = 1) readonly buffer InputPositions {
    dVec3Wrapper input_positions[];
};

layout(set = 0, binding = 2) readonly buffer InputVelocities {
    dVec3Wrapper input_velocities[];
};

layout(set = 0, binding = 3) readonly buffer InputPressures {
    double input_pressures[];
};

layout(set = 0, binding = 4) readonly buffer FlatCells {
    CellInfo flat_cells[];
};

// These are not actually necessary, just for debugging
layout(set = 0, binding = 5) buffer DebugForces {
    dVec3Wrapper debug_forces[];
};

layout(set = 0, binding = 6) buffer OutputPositions {
    dVec3Wrapper output_positions[];
};

layout(set = 0, binding = 7) buffer OutputVelocities {
    dVec3Wrapper output_velocities[];
};


layout(push_constant) uniform Params {
    uint nBits;
    uint nParticles;
    dvec3 domainMin;
    dvec3 domainMax;
    int d;
    double dt;
    double h;
    double mass;
    dvec3 body_force;
} pc;

#include "morton_kernels.comp.kern"
#include "kernels.comp.kern"
#include "nbr_kernel.comp.kern"

void main() {
    uint idx = gl_GlobalInvocationID.x;

    dvec3 pos = input_positions[idx].data;
    uvec3 ijk = xyz2ijk(pos, pc.nBits);
    uint flat_key = ijk2ak(ijk, pc.nBits);

    CellInfo cell = flat_cells[flat_key];

    int d = pc.d;
    uint maxg = 1 << pc.nBits;

    CellInfo neighborCells[MAX_CELLS];
    uint cellCount;
    gather_neighbor_cells(ijk, d, maxg, neighborCells, cellCount);

    dvec3 pressure_force = dvec3(0.0, 0.0, 0.0);
    // now consume neighbors
    for (uint c = 0u; c < cellCount; ++c) {
        CellInfo cell = neighborCells[c];
        for (uint i = cell.left; i < cell.right; ++i) {
            if (i == idx) continue;
            dvec3 dv = input_positions[i].data - pos;
            double dist = length(dv);
            dvec3 gradw = debrun_spiky_kernel_grad(dv, pc.h);
            dvec3 contrib = cal_pressure_force_ij(
                gradw,
                input_pressures[idx],
                input_pressures[i],
                input_densities[idx], 
                input_densities[i],
                pc.mass // mass
            );
            pressure_force += contrib;
        }
    }
    dvec3 ftot = pressure_force + pc.body_force;
    debug_forces[idx].data = ftot;
    dvec3 newvel = input_velocities[idx].data + ftot * pc.dt / pc.mass;

    // finally, deal with boundaries
    // where will it go?
    
    BoundaryResult br = adjust_boundary_bounce(input_positions[idx].data, newvel, pc.domainMin, pc.domainMax, pc.dt, 0.75);
    
    output_velocities[idx].data = br.vel;
    output_positions[idx].data = br.pos;
}