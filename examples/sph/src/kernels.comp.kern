// Constants
const double PI = 3.14159265359;
const double D15 = 15.0;
const double D6 = 6.0;
const double MINDIST = 1e-6;

double get_debrun_coeff_3D(double h) {
    double hp6 = h * h * h * h * h * h;
    return D15 / (PI * hp6);
}

double debrun_spiky_kernel(double r, double h) {
    double coeff = get_debrun_coeff_3D(h);
    double hmr = h-r;
    double hmr_pow3 = hmr * hmr * hmr;
    double val = coeff * hmr_pow3;
    double mask = step(0.0, r) * step(r, h); // 1.0 if 0 <= r <= h, else 0.0
    return val * mask;
}

double debrun_spiky_kernel_dwdr(double r, double h) {
    double coeff = get_debrun_coeff_3D(h);
    double hmr = h-r;
    double hmr_pow2 = hmr * hmr;
    double val = -3.0 * coeff * hmr_pow2;
    double mask = step(0.0, r) * step(r, h);
    return val * mask;
}

double debrun_spiky_kernel_lap(double r, double h) {
    double mask = r < h ? 1.0 : 0.0;
    double coeff = D6 * get_debrun_coeff_3D(h);
    double term1 = coeff * (h - r);          // W''(r)
    double term2 = - coeff * (h - r) * (h - r) / r;  // (2/r) * W'(r)
    return mask * (term1 + term2);
}

dvec3 debrun_spiky_kernel_grad(dvec3 dv, double h) {
    double r = length(dv);
    double safe_r = max(r, MINDIST); // avoid divide-by-zero
    double dwdror = debrun_spiky_kernel_dwdr(r, h) / safe_r;
    return dv * dwdror;
}

double poly6_kernel(double r, double h) {
    if (r < 0.0 || r > h) return 0.0;
    double hr = (h*h - r*r);
    double ph9 = h * h * h * h * h * h * h * h * h;
    return (315.0 / (64.0 * PI * ph9)) * hr * hr * hr;
}

// Wendland C2 kernel (3D)
double wendland_kernel(double r, double h) {
    if (r < 0.0 || r > h) return 0.0;
    double q = r / h;
    double factor = (1.0 - q);
    double coeff = 21.0 / (2.0 * PI * h * h * h);
    return coeff * factor * factor * factor * factor * (1.0 + 4.0 * q);
}

// Gradient of Wendland kernel (3D)
dvec3 wendland_kernel_grad(dvec3 dv, double h) {
    double r = length(dv);
    if (r <= 0.0 || r > h) return dvec3(0.0);
    double q = r / h;
    double coeff = 21.0 / (2.0 * PI * h * h * h);
    double onemq = 1.0 - q;
    double dwdr = coeff * (-20.0 / (h * h)) * q * onemq * onemq * onemq;
    return dv * (dwdr / r); // normalize by r
}

// Laplacian of Wendland kernel (3D)
double wendland_kernel_lap(double r, double h) {
    if (r < 0.0 || r > h) return 0.0;
    double q = r / h;
    double coeff = 21.0 / (2.0 * PI * h * h * h);
    double onemq = 1.0 - q;
    return coeff * (-20.0 / (h * h)) * onemq * onemq * (1.0 - 4.0 * q);
}

double cal_pressure_wcsph(double rho, double rho0, double c2, int gamma) {
    // bweak is a constant for this call
    double bweak = c2 * rho0 / double(gamma);
    double prod = 1.0;
    for (int g = 0; g < gamma; ++g) {
        prod = prod * rho / rho0;
    }
    return bweak * (prod - 1.0f);
}

double cal_pressure_wc_simple(double rho, double rho0, double c2) {
    return c2 * (rho - rho0);
}

double cal_rho_ij(double mass, double dist_ij, double h) {
    // formula is mass * kernel, mass = 1.0
    return mass * wendland_kernel(dist_ij, h);
}

double cal_pressure_force_coefficient(double pi, double pj, double rhoi, double rhoj, double mj) {
    return ((pi / (rhoi * rhoi)) + (pj / (rhoj * rhoj))) * mj;
}

dvec3 cal_pressure_force_ij(dvec3 gradw, double pi, double pj, double rhoi, double rhoj, double mj) {
    double pforce_coefficient = - cal_pressure_force_coefficient(pi, pj, rhoi, rhoj, mj);
    return pforce_coefficient * gradw;
}

struct BoundaryResult {
    dvec3 pos;
    dvec3 vel;
};

BoundaryResult adjust_boundary_bounce(dvec3 pos, dvec3 vel, dvec3 bmin, dvec3 bmax, double dt, double damping) {
    dvec3 new_pos = pos;
    dvec3 new_vel = vel;
    BoundaryResult br;

    // Axis-wise collision
    for (int axis = 0; axis < 3; ++axis) {
        double prop = new_pos[axis] + new_vel[axis] * dt;

        if (prop > bmax[axis] && new_vel[axis] > 0.0) {
            double t_hit = (bmax[axis] - new_pos[axis]) / new_vel[axis];
            new_pos[axis] = pos[axis] + vel[axis] * t_hit;
            new_vel[axis] *= -1.0;                     // reflect
            new_pos[axis] += new_vel[axis] * (dt - t_hit); // remaining step
        } else if (prop < bmin[axis] && new_vel[axis] < 0.0) {
            double t_hit = (bmin[axis] - new_pos[axis]) / new_vel[axis];
            new_pos[axis] = pos[axis] + vel[axis] * t_hit;
            new_vel[axis] *= -1.0;                     // reflect
            new_pos[axis] += new_vel[axis] * (dt - t_hit); // remaining step
        }
        else {
            new_pos[axis] = prop; // no collision
        }
    }

    // Optional: final clamp to ensure strictly inside
    for (int axis = 0; axis < 3; ++axis) {
        if (new_pos[axis] < bmin[axis]) new_pos[axis] = bmin[axis];
        if (new_pos[axis] > bmax[axis]) new_pos[axis] = bmax[axis];
    }

    br.pos = new_pos;
    br.vel = new_vel;
    return br;
}

double viscosity_kernel_lap(double r, double h) {
    if (r >= h) return 0.0;
    double hp6 = h * h * h * h * h * h;
    return (45.0 / (PI * hp6)) * (h - r);
}

dvec3 viscosityForce(
    dvec3 pos_i, dvec3 pos_j,
    dvec3 vel_i, dvec3 vel_j,
    double mu, double mass_j,
    double rho_i, double rho_j,
    double h
) {
    dvec3 r = pos_i - pos_j;
    double rLen = length(r);

    double laplacian = wendland_kernel_lap(rLen, h);

    // Symmetric density average
    double rho_avg = 0.5 * (rho_i + rho_j);

    return mu * mass_j * (vel_j - vel_i) / rho_avg * laplacian;
}
