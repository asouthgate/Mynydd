
const uint MAX_CELLS = 27; // d=1

void gather_neighbor_cells(
    uvec3 ijk,
    int d,
    uint maxg,
    out CellInfo cells[MAX_CELLS],
    out uint count
) {
    count = 0;
    for (int di = -d; di <= d; ++di) {
        for (int dj = -d; dj <= d; ++dj) {
            for (int dk = -d; dk <= d; ++dk) {
                int ip = int(ijk.x) + di;
                int jp = int(ijk.y) + dj;
                int kp = int(ijk.z) + dk;

                if (ip >= 0 && ip < int(maxg) &&
                    jp >= 0 && jp < int(maxg) &&
                    kp >= 0 && kp < int(maxg)) {
                    
                    uint flat_keyp = ijk2ak(uvec3(ip,jp,kp), pc.nBits);
                    cells[count++] = flat_cells[flat_keyp];
                }
            }
        }
    }
}

bool segmentIntersectsTriangleAndReflect(
    dvec3 v0, dvec3 v1, dvec3 v2,
    dvec3 p0, dvec3 p1,
    dvec3 vel,
    out dvec3 hitPoint,
    out dvec3 reflectedVel
) {
    vec4 params = computeIntersectionParams(v0, v1, v2, p0, p1);

    if (isParallel(params))      return false;
    if (isOutsideUV(params))     return false;
    if (!doesIntersect(params)) return false;

    // Reconstruct intersection point
    double t = params.z;
    dvec3 dir = p1 - p0;
    hitPoint  = p0 + dir * t;

    // Triangle normal
    dvec3 normal = normalize(cross(v1 - v0, v2 - v0));
    if (dot(vel, normal) > 0.0) normal = -normal;

    reflectedVel = reflect(vel, normal);
    return true;
}