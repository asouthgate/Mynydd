#version 450
layout(local_size_x = 256) in;

#extension GL_GOOGLE_include_directive : enable
#include "morton_kernels.comp.kern"
#include "kernels.comp.kern"

const uint MAX_CELLS = 27; // d=1

struct Vec3Wrapper {
    vec3 data;
};

struct CellInfo {
    uint left;
    uint right;
};

// THESE SHOULD BE SORTED
layout(set = 0, binding = 0) readonly buffer InputDensities {
    float input_densities[];
};

layout(set = 0, binding = 1) readonly buffer InputPositions {
    Vec3Wrapper input_positions[];
};

layout(set = 0, binding = 2) readonly buffer SortedKeys {
    uint keys[];
};

layout(set = 0, binding = 3) readonly buffer FlatCells {
    CellInfo flat_cells[];
};

layout(set = 0, binding = 4) readonly buffer Cells {
    CellInfo cells[];
};

layout(set = 0, binding = 5) buffer Densities {
    float densities[];
};

layout(set = 0, binding = 1) readonly buffer PressureForces {
    Vec3Wrapper pressure_forces[];
};


layout(push_constant) uniform Params {
    uint nBits;
    uint nParticles;
    vec3 domainMin;
    vec3 domainMax;
    int d;
} pc;

void gather_neighbor_cells(
    uvec3 ijk,
    int d,
    uint maxg,
    out CellInfo cells[MAX_CELLS],
    out uint count
) {
    count = 0;
    for (int di = -d; di <= d; ++di) {
        for (int dj = -d; dj <= d; ++dj) {
            for (int dk = -d; dk <= d; ++dk) {
                int ip = int(ijk.x) + di;
                int jp = int(ijk.y) + dj;
                int kp = int(ijk.z) + dk;

                if (ip >= 0 && ip < int(maxg) &&
                    jp >= 0 && jp < int(maxg) &&
                    kp >= 0 && kp < int(maxg)) {
                    
                    uint flat_keyp = ijk2ak(uvec3(ip,jp,kp), pc.nBits);
                    cells[count++] = flat_cells[flat_keyp];
                }
            }
        }
    }
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint key = keys[idx];

    vec3 pos = input_positions[idx].data;
    uvec3 ijk = xyz2ijk(pos, pc.nBits);
    uint flat_key = ijk2ak(ijk, pc.nBits);

    //CellInfo cell = cells[key];
    CellInfo cell = flat_cells[flat_key];

    float densitySum = 0.0;
    //uint count = cell.right - cell.left;
    uint count = 0;

    int d = pc.d;
    uint maxg = 1 << pc.nBits;

    CellInfo neighborCells[MAX_CELLS];
    uint cellCount;
    gather_neighbor_cells(ijk, d, maxg, neighborCells, cellCount);

    // now consume neighbors
    for (uint c = 0u; c < cellCount; ++c) {
        CellInfo cell = neighborCells[c];
        for (uint i = cell.left; i < cell.right; ++i) {
            float dist = length(input_positions[i].data - pos);
            densitySum += cal_rho_ij(1.0, dist, 1.0);
            count += 1;
        }
    }

    densities[idx] = densitySum;

    //pressure_forces[idx] = 

}